# Copyright 2014 Scalyr Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------------------------
#
# A ScalyrMonitor that collects metrics on a running Windows process.  The
# collected metrics include CPU and memory usage.
#
# Note, this can be run in standalone mode by:
#     $ python -m scalyr_agent.run_monitor scalyr_agent.builtin_monitors.windows_process_metrics -c "{pid:1234}"
#
#   where 1234 is the process id of the target process.
# See documentation for other ways to match processes.
#
# author:  Scott Sullivan <guy.hoozdis@gmail.com>

__author__ = 'guy.hoozdis@gmail.com'
__monitor__ = __name__


import os
#from subprocess import Popen, PIPE
from scalyr_agent import ScalyrMonitor, BadMonitorConfiguration
from scalyr_agent import define_config_option, define_metric, define_log_field





#
# Monitor Configuration - defines the runtime environment and resources available
#
CONFIG_OPTIONS = [
    dict(
        option_name='module',
        option_description='Always ``scalyr_agent.builtin_monitors.linux_process_metrics``',
        convert_to=str,
        required_option=True
    ),
    dict(
        option_name='commandline',
        option_description='A regular expression which will match the command line of the process you\'re interested '
        'in, as shown in the output of ``ps aux``. (If multiple processes match the same command line pattern, '
        'only one will be monitored.)',
        default=None,
        convert_to=str
    ),
    dict(
        option_name='pid',
        option_description='The pid of the process from which the monitor instance will collect metrics.  This is '
        'ignored if the ``commandline`` is specified.',
        default=None,
        convert_to=str
    ),
    dict(
        option_name='id',
        option_description='Included in each log message generated by this monitor, as a field named ``instance``. '
        'Allows you to distinguish between values recorded by different monitors.',
        required_option=True,
        convert_to=str
    )
]

_ = [define_config_option(__monitor__, **option) for option in CONFIG_OPTIONS] # pylint: disable=star-args



#
# Process's Metrics / Dimensions - defines the capibilities of this monitor
#
METRICS = [

    # A Process's CPU time
    dict(
        metric_name='winproc.cpu',
        description='User-mode CPU usage, in 1/100ths of a second.',
        extra_fields={'type': 'user'},
        unit='secs:0.01',
        cumulative=True
    ),
    dict(
        metric_name='winproc.cpu',
        description='System-mode CPU usage, in 1/100ths of a second.',
        extra_fields={'type': 'system'},
        unit='secs:0.01',
        cumulative=True
    ),

    # A Process's uptime/lifetime
    dict(
        metric_name='winproc.uptime',
        description='Process uptime, in milliseconds.',
        unit='milliseconds',
        cumulative=True
    ),

    # A Processes's Threads
    dict(
        metric_name='winproc.threads',
        description='The number of threads being used by the process.'
    ),

    # A Process's Memory Consumption
    dict(
        metric_name='winproc.mem.bytes',
        description='Virtual memory usage, in bytes.',
        extra_fields={'type': 'vmsize'},
        unit='bytes'
    ),
    dict(
        metric_name='winproc.mem.bytes',
        description='Resident memory usage, in bytes.',
        extra_fields={'type': 'resident'},
        unit='bytes'
    ),
    dict(
        metric_name='winproc.mem.bytes',
        description='Peak virtual memory usage, in bytes.',
        extra_fields={'type': 'peak_vmsize'},
        unit='bytes'
    ),
    dict(
        metric_name='winproc.mem.bytes',
        description='Peak resident memory usage, in bytes.',
        extra_fields={'type': 'peak_resident'},
        unit='bytes'
    ),

    # A Process's Disk Activity
    dict(
        metric_name='winproc.disk.operations',
        description='Total disk read requests.',
        extra_fields={'type': 'read'},
        unit='bytes',
        cumulative=True
    ),
    dict(
        metric_name='app.disk.operations',
        description='Total disk write requests.',
        extra_fields={'type': 'write'},
        unit='bytes',
        cumulative=True
    ),
    dict(
        metric_name='app.disk.operations',
        description='Total disk write requests.',
        extra_fields={'type': 'other'},
        unit='bytes',
        cumulative=True
    ),
    dict(
        metric_name='winproc.disk.bytes',
        description='Total bytes read from disk.',
        extra_fields={'type': 'read'},
        unit='bytes',
        cumulative=True
    ),
    dict(
        metric_name='winproc.disk.bytes',
        description='Total bytes written to disk.',
        extra_fields={'type': 'write'},
        unit='bytes',
        cumulative=True
    ),
    dict(
        metric_name='winproc.disk.bytes',
        description='Total other bytes.',
        extra_fields={'type': 'other'},
        unit='bytes',
        cumulative=True
    ),
]

_ = [define_metric(__monitor__, **metric) for metric in METRICS] # pylint: disable=star-args



#
# Logging / Reporting - defines the method and content in which the metrics are reported.
#
define_log_field(__monitor__, 'monitor', 'Always ``linux_process_metrics``.')
define_log_field(__monitor__, 'instance', 'The ``id`` value from the monitor configuration, e.g. ``tomcat``.')
define_log_field(__monitor__, 'app', 'Same as ``instance``; provided for compatibility with the original Scalyr Agent.')
define_log_field(__monitor__, 'metric', 'The name of a metric being measured, e.g. "app.cpu".')
define_log_field(__monitor__, 'value', 'The metric value.')





class ProcessMonitor(ScalyrMonitor):
    """A Scalyr agent monitor that records metrics about a running process.

    To configure this monitor, you need to provide an id for the instance to identify which process the metrics
    belong to in the logs and a regular expression to match against the list of running processes to determine which
    process should be monitored.

    Example:
      monitors: [{
         module: "builtin_monitors.windows_process_metrics".
         id: "tomcat",
         commandline: "java.*tomcat",
      }]

    Instead of 'commandline', you may also define the 'pid' field which should be set to the id of the process to
    monitor.  However, since ids can change over time, it's better to use the commandline matcher.  The 'pid' field
    is mainly used by the Windows process monitor run to monitor the agent itself.

    This monitor records the following metrics:
    TODO: Generate the list of metrics collected

    In additional to the fields listed above, each metric will also have a field 'winproc' set to the monitor id to
    specify which process the metric belongs to.

    You can run multiple instances of this monitor per agent to monitor different processes.
    """
    def _initialize(self):
        """Performs monitor-specific initialization."""
        # The id of the process being monitored, if one has been matched.
        self.__pid = None
        # The list of BaseReaders instantiated to gather metrics for the process.
        self.__gathers = []

        self.__id = self._config.get('id', required_field=True, convert_to=str)
        self.__commandline_matcher = self._config.get('commandline', default=None, convert_to=str)
        self.__target_pid = self._config.get('pid', default=None, convert_to=str)

        if self.__commandline_matcher is None and self.__target_pid is None:
            raise BadMonitorConfiguration('At least one of the following fields must be provide: commandline or pid',
                                          'commandline')

        # Make sure to set our configuration so that the proper parser is used.
        self.log_config = {
            'parser': 'agent-metrics',
            'path': 'windows_process_metrics.log',
        }

    def __set_process(self, pid):
        """Sets the id of the process for which this monitor instance should record metrics.

        @param pid: The process id or None if there is no process to monitor.
        @type pid: int or None
        """
        if self.__pid is not None:
            for gather in self.__gathers:
                gather.close()

        self.__pid = pid
        self.__gathers = []

        if pid is not None:
            pass
            #self.__gathers.append(StatReader(self.__pid, self.__id, self._logger))
            #self.__gathers.append(StatusReader(self.__pid, self.__id, self._logger))
            #self.__gathers.append(IoReader(self.__pid, self.__id, self._logger))
        # TODO: Re-enable these if we can find a way to get them to truly report
        # per-app statistics.
        #        self.gathers.append(NetStatReader(self.pid, self.id, self._logger))
        #        self.gathers.append(SockStatReader(self.pid, self.id, self._logger))

    def gather_sample(self):
        """Collect the per-process metrics for the monitored process.

        If the process is no longer running, then attempts to match a new one.
        """
        if self.__pid is not None and not self.__is_running():
            self.__set_process(None)

        if self.__pid is None:
            self.__set_process(self.__select_process())

        #for gather in self.__gathers:
        #    gather.run_single_cycle()
        self._logger.emit_value('dimension', 'metric value')

    def __select_process(self):
        """Returns the process id of a running process that fulfills the match criteria.

        This will either use the commandline matcher or the target pid to find the process.
        If no process is matched, None is returned.

        @return: The process id of the matching process, or None
        @rtype: int or None
        """
        sub_proc = None
        if self.__commandline_matcher is not None:
            try:
                pass
                # Spawn a process to run ps and match on the command line.  We only output two
                # fields from ps.. the pid and command.
                #sub_proc = Popen(['ps', 'ax', '-o', 'pid,command'],
                #                 shell=False, stdout=PIPE)
                #
                #sub_proc.stdout.readline()
                #for line in sub_proc.stdout:
                #    line = line.strip()
                #    if line.find(' ') > 0:
                #        pid = int(line[:line.find(' ')])
                #        line = line[(line.find(' ') + 1):]
                #        if re.search(self.__commandline_matcher, line) is not None:
                #            return pid
                #return None
            finally:
                # Be sure to wait on the spawn process.
                if sub_proc is not None:
                    sub_proc.wait()
        else:
            # See if the specified target pid is running.  If so, then return it.
            try:
                # Special case '$$' to mean this process.
                if self.__target_pid == '$$':
                    pid = os.getpid()
                #else:
                    #pid = int(self.__target_pid)
                #os.kill(pid, 0)
                return pid
            except OSError:
                # If we get this, it means we tried to signal a process we do not have permission to signal.
                # If this is the case, we won't have permission to read its stats files either, so we ignore it.
                return None

    def __is_running(self):
        """Returns true if the current process is still running.

        @return:  True if the monitored process is still running.
        @rtype: bool
        """
        try:
            os.kill(self.__pid, 0)
            return True
        except OSError, e:
            # Errno #3 corresponds to the process not running.  We could get
            # other errors like this process does not have permission to send
            # a signal to self.pid.  But, if that error is returned to us, we
            # know the process is running at least, so we ignore the error.
            return e.errno != 3


__all__ = ['ProcessMonitor']
